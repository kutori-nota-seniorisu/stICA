%% 仿真数据Pulse筛选
clear; clc; close all;
load('./Data/experiment/24-06-21/UUS-iEMG/S1M1L1T1P2_USCBSS_compo25.mat');
% datasets_num = '10';
% load(['./Data/simulation/datasets' datasets_num '/USCBSS_compo10.mat']);
%% 初步筛选
% 保留的脉冲串
decompoPulseAll = {};
% 保留的估计源
decompoSourceAll = [];
% 保留的一阶段估计源
decompoSourceFirstAll = [];
% 保留的CoV
decompoCoVAll = [];
for r = 1:size(DecompoResults.decompo_pulses, 1)
    for c = 1:size(DecompoResults.decompo_pulses, 2)

        % disp(['row=' num2str(r) ',col=' num2str(c)]);
        tmpPulses = DecompoResults.decompo_pulses{r, c};
        tmpSourcesFirst = DecompoResults.sourceFirst{r, c};
        tmpSources = DecompoResults.sources{r, c};
        tmpCoV = DecompoResults.CoV{r, c};
        % rho = corr(sources);
        for mu = 1:length(tmpPulses)
            if isempty(tmpPulses{mu})
                continue;
            end
            % 放电时间间隔的MAD
            % pulseInt = diff(decompo_pulses{mu}/2);
            % MAD = mean(abs(pulseInt - mean(pulseInt)));
            % if MAD > 25
            %     disp(['MU=' num2str(mu) ',MAD=' num2str(MAD)]);
            %     continue;
            % end

            if isempty(decompoPulseAll)
                decompoPulseAll{end+1} = tmpPulses{mu};
                decompoSourceAll(:, end+1) = tmpSources(:, mu);
                decompoSourceFirstAll(:, end+1) = tmpSourcesFirst(:, mu);
                decompoCoVAll(end+1) = tmpCoV(mu);
            end

            for ii = 1:size(decompoSourceAll, 2)
                [tmp, ~] = xcorr(decompoSourceAll(:, ii), tmpSources(:, mu), 'coeff');
                corrVals(ii) = max(abs(tmp));
            end

            [maxVal, idx] = max(corrVals);
            if maxVal > 0.3
                % disp('检测到相关序列');
                % 若新的脉冲序列CoV小于旧的脉冲序列，则更新
                if decompoCoVAll(idx) > tmpCoV(mu)
                    disp(['更新MU #' num2str(idx)])
                    decompoPulseAll{idx} = tmpPulses{mu};
                    decompoSourceAll(:, idx) = tmpSources(:, mu);
                    decompoSourceFirstAll(:, idx) = tmpSourcesFirst(:, mu);
                    decompoCoVAll(idx) = tmpCoV(mu);
                    % else
                    %     disp('未更新');
                end
                continue;
            else
                decompoPulseAll{end+1} = tmpPulses{mu};
                decompoSourceAll(:, end+1) = tmpSources(:, mu);
                decompoSourceFirstAll(:, end+1) = tmpSourcesFirst(:, mu);
                decompoCoVAll(end+1) = tmpCoV(mu);
                disp(['MU=' num2str(mu) '保留']);
            end
        end
    end
end
%% 去除噪声，去除标准为能量占比
L = size(decompoSour);
delInd = [];
for muii = 1:size(decompoSourceAll, 2)
    % 傅里叶变换
    tmp = abs(fft(decompoSourceAll(:, muii))/L);
    sFFT = tmp(1:L/2+1);
    sFFT(2:end-1) = 2*sFFT(2:end-1);
    energyRatio = sum(sFFT(1:100)) / sum(sFFT);
    if energyRatio < 0.2
        delInd(end+1) = muii;
        % disp(['MU=' num2str(mu) ',Ratio=' num2str(energyRatio)]);
        % continue;
    end
    % figure;
    % subplot(3,1,1);
    % scatter(decompoPulseAll{muii}, ones(length(decompoPulseAll{muii})), 1000, "black", '|');
    % subplot(3,1,2);
    % plot(decompoSourceAll(:, muii));
    % subplot(3,1,3);
    % plot(f, sFFT);
    % title(['energy='  num2str(energyRatio*100) '%']);
    % sgtitle(['MU #' num2str(muii)]);
end

decompoPulseAll(delInd) = [];
decompoSourceAll(:, delInd) = [];
decompoSourceFirstAll(:, delInd) = [];
decompoCoVAll(delInd) = [];

%% 二次筛选
% 计算带有时延的互相关系数
[cc, ~] = xcorr(decompoSourceAll, 'coeff');
% 转成三维数组
cc = reshape(cc', size(decompoSourceAll, 2), size(decompoSourceAll, 2), []);
% 计算互相关系数的最大值
ccMax = max(abs(cc), [], 3);
% % 生成掩膜。只关注矩阵的上三角部分，不包含对角线，避免重复比较。
% % mask是一个逻辑矩阵，下三角及主对角线部分均为零，上三角部分只有大于阈值的位置才为一。
% mask = triu(ccMax > 0.7, 1);
% % 初始化保留索引
% toKeep = true(size(decompoSourceAll, 2), 1);
% % 遍历mask矩阵，找到所有要删除的j
% for i = 1:size(decompoSourceAll, 2)
%     j_toRemove = find(mask(i, :));
%     toKeep(j_toRemove) = false;
% end
% 
% decompoSourceAll = decompoSourceAll(:, toKeep);
% decompoCoVAll = decompoCoVAll(toKeep);
% decompoPulseAll = decompoPulseAll(toKeep);

%% 绘制筛选后的MU
close all;
fsampu = 2000;
L = 4000;
f = (0:1:L/2) * fsampu / L;
delInd = [];
for muii = 1:size(decompoSourceAll, 2)
    % 傅里叶变换
    tmp = abs(fft(decompoSourceAll(:, muii))/L);
    sFFT = tmp(1:L/2+1);
    sFFT(2:end-1) = 2*sFFT(2:end-1);
    energyRatio = sum(sFFT(1:100)) / sum(sFFT);

    figure;
    subplot(3,1,1);
    scatter(decompoPulseAll{muii}, ones(length(decompoPulseAll{muii})), 1000, "black", '|');
    xlim([0, 4000])
    title('spike train')
    subplot(3,1,2);
    plot(decompoSourceFirstAll(:, muii));
    hold on
    plot(decompoSourceAll(:, muii));
    title('estimated source')
    legend('phase 1', 'phase 2')
    subplot(3,1,3);
    plot(f, sFFT);
    title(['ratio='  num2str(energyRatio*100) '%']);
    sgtitle(['MU #' num2str(muii)]);
end

